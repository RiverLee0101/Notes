# 一、Java设计模式

- 设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规则，而是一套用来提高代码可复用性、可维护度、稳健性以及安全性的解决方案。
- 这23种设计模式的本质是面向对象原则的实际运用，**是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解**。正确使用设计模式有以下优点：
  - 可以提高程序员的思维能力、编程能力和设计能力。
  - 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
  - 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。



## 1. 软件设计模式概述

- 软件设计模式的基本要素

  1. 模式名称

     每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们讨论自己的设计。

  2. 问题

     问题描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。

  3. 解决方案

     模式问题的解决方案包括设计的组成成分、它们之间的相互关系及各自的职责和写作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。

  4. 效果

     描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。



## 2. GoF的23种设计模式的分类和功能

### 2.1 根据目的来分

根据模式是用来完成什么工作来划分，这种方式可分为 **创建型模式、结构型模式、行为型模式** 三种。

1. **创建型模式**：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。
2. **结构型模式**：用于描述如何将类或对象按某种布局组成更大的结构。
3. **行为型模式**：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配自己的职责。

### 2.2 根据作用范围来分

根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为 **类模式** 和 **对象模式** 两种。

1. **类模式**：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。
2. **对象模式**：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。

| 范围/目的 |          创建型模式          |                     结构型模式                     |                          行为型模式                          |
| :-------: | :--------------------------: | :------------------------------------------------: | :----------------------------------------------------------: |
|  类模式   |           工厂方法           |                    （类）适配器                    |                       模板方法、解释器                       |
| 对象模式  | 单例、原型、抽象工厂、建造者 | 代理、对象（适配器）、桥接、装饰、外观、享元、组合 | 策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录 |



## 3. java设计模式

### 3.1 适配器模式

- 适配器（Adapter）模式的定义与特点：将一个类的接口转换成客户希望的另一个接口，使得原本因为接口不兼容而不能一起工作的类能一起工作。适配器模式分为 **类结构型模式 **和 **对象结构型模式 **两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

- 适配器模式的主要优点如下：

  - 客户端通过适配器可以透明地调用目标接口；
  - 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类；
  - 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题；

- 缺点：

  - 对类适配器来说，更换适配器的实现过程比较复杂；

- 应用场景：

  - 接口中有很多个方法，而只想实现其中的某些方法，可以用接口适配器实现接口中的所有方法，可以写成空方法，然后其他需要调用接口的类实现这个适配器类，就可以重写其中的某些需要使用的方法。

- 适配器（Adapter）模式的结构：

  1. **目标（Target）接口**：当前系统业务所期待的接口，它可以是抽象类或接口；
  2. **适配者（Adaptee）类**：它是被访问和适配的现存组件库中的组件接口；
  3. **适配器（Adapter）类**：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者；

- 类适配器模式的结构图：

  ![类适配器模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151045351c.gif)

- 对象适配器模式的结构图：

  ![对象适配器模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151046105A.gif)

- 模式的实现：

  - 类适配器模式的代码：

    ```java
    // 将被适配的类
    package adapter;
    public class adaptee{
        public void adapteeRequest(){
            System.out.println("被适配者的方法");
        }
    }
    ```

    ```java
    // 定义一个目标接口
    public interface Target{
        public void request();
    }
    ```

    > 怎么才可以在目标接口中的 **request()** 调用 **Adaptee** 的 **adapteeRequest()** 方法呢？
    >
    > 如果直接实现Target是不行的。
    >
    > 如果通过一个适配器类，**实现Target接口**，同时**继承Adaptee类**，然后在实现的request方法中调用父类的adapteeRequest()即可实现。

    ```java
    // 适配器类
    public class Adapter extends Adaptee implements Target{
        @Override
        publiv void request(){
            // ...其他操作...
            super.adapteeRequest();
            // ...其他操作...
        }
    }
    ```

    ```java
    public class Test{
        public static void main(String[] args){
            Target adapterTarget = new Adapter();
            adapterTarget.request();
        }
    }
    ```

  - 对象适配器的代码：

    > 对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器通过**关联**来完成，这里稍微修改一下 Adapter 类即可转变为对象适配器。

    ```java
    public class Adapter implements Target{
        // 适配者是对象适配器的一个属性
        private Adaptee adaptee = new Adaptee();
        
        @Override
        public void request(){
            // ...
            adaptee.adapteeRequest();
            // ...
        }
        
    }
    ```

    

### 3.2 责任链模式



# 二、软件设计原则-7条开发原则

在软件开发中，为了提高系统的 可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据7条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。这7条开发原则分别是：

- 开闭原则
- 里式替换原则
- 依赖倒置原则
- 单一职责原则
- 接口隔离原则
- 迪米特法则
- 合成复用原则

## 1. 开闭原则

### 1.1 开闭原则的定义

- **经典定义**：***软件实体应当对扩展开放，对修改关闭***（Software entities should be open for extension, but closed for modification）。
- **软件实体：**
  - 项目中划分出的模块
  - 类与接口
  - 方法
- **开闭原则的含义是：**当应用需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

### 1.2 开闭原则的作用

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活的同时具备稳定性和延续性，具体来说其作用如下：

1. **对软件测试的影响：**

   软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

2. **可以提高代码的可复用性：**

   粒度越小，被复用的可能性越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

3. **可以提高软件的可维护度：**

   遵守开闭原则的软件，其稳定性高延续性强，从而易于扩展和维护。

### 1.3 开闭原则的实现方法

可以通过“**抽象约束、封装变化**”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实体类来扩展就可以了。



## 2. 里式替换原则

### 2.1 里式替换原则的定义

- 继承必须确保超类所拥有的性质在子类中仍然成立。
- 里式替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里式替换原是继承复用的基础，它**反映了基类和子类之间的关系**，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

### 2.2 里式替换原则的作用

1. 里式替换原则是实现开闭原则的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

### 2.3 里式替换原则的实现方法

- 里式替换原则通俗来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

- 实例：

  鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”。例子中几维鸟重写了`setSpeed(double speed)`方法，将speed=0，在计算飞行时间的时候distance/speed就会出错。



## 3. 依赖倒置原则

### 3.1 依赖倒置原则的定义

- 原始定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：**要面向接口编程，不要面向实现编程**。
- 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。
- 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的 **抽象指的是接口或抽象类，而细节是指具体的实现类**。
- **使用接口或抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成**。

### 3.2 依赖、倒置原则的作用

- 降低类间的耦合性。
- 提高系统的稳定性。
- 减少并行开发引起的风险。
- 提高代码的可读性和可维护性。

### 3.3 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中要遵循以下4点，就能在项目中满足这个规则：

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵守里式替换原则。



## 4. 单一责任原则

### 4.1 单一责任原则的定义

- 这里的职责是指类变化的原因，***单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分***。
- 该原则提出对象不应该承担太多职责，如果一个对象承担了太多职责，至少存在以下两个缺点：
  1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
  2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

### 4.2 单一责任原则的优点

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂度降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

### 4.3 单一责任原则的实现方法

单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。



## 5. 接口隔离原则

### 5.1 接口隔离原则的定义

- 接口隔离原则（Interface Segregation Principle, ISP）要**求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法**。
- 客户端不应该被迫依赖于它不使用的方法。
- 一个类对另一个类的依赖应该建立在最小的接口上。
- 以上三个定义的含义是：**要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用**。
- 接口隔离原则和单一职责原则都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
  - 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
  - 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

### 5.2 接口隔离原则的优点

接口隔离是为了约束接口、降低类对接口的依赖性，遵循接口隔离有以下5个优点：

1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离为了提高系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

### 5.3 接口隔离原则的实现方法

在具体应用接口隔离原则时，应该根据以下几个规则来衡量：

1. 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
2. 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
3. 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，深入了解业务逻辑。
4. 提高内聚，减少对外交互。使接口用最少的方法去完成很多的事情。、



## 6. 迪米特法则

### 6.1 迪米特法则的定义

- 迪米特法则（Law of Demeter, LoD）又叫做最少知识原则（Least Knowledge Principle, LKP），其定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：**如果两个软件实体无须直接通信，那么就不因当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类间的耦合度，提高模块的相对独立性**。
- 迪米特法则中的“朋友”是指：当前对象本身，当前对象的成员对象，当前对象所创建的对象，当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

### 6.2 迪米特法则的优点

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲和度降低，从而提高了类的可复用率和系统的扩展性。

### 6.3 迪米特法则的实现方法

从迪米特法则的定义和特点可知，它强调以下两点：

1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。



## 7. 合成复用原则

### 7.1 合成复用原则的定义

- 合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。**它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现**。
- **如果使用继承关系，则必须严格遵循里式替换原则**。合成复用原则同里式替换原则相辅相成的，两者都是开闭原则的具体实现规范。

### 7.2 合成复用原则的重要性

通常类的复用分为**继承复用**和**合成复用**两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类和父类的耦合度高。父类实现的任何改变都会导致子类发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

### 7.3 合成复用原则的实现方法

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。