# 数据结构

- **什么是数据结构：**
  - 《算法+数据结构=编程》，简单地说，数据结构是“**以某种特定的布局方式储存数据的容器**”。这种“**布局方式**”决定了数据结构对于某些操作是高效的，而对于其他操作是低效的。
- **为什么我们需要数据结构：**
  - 数据是计算机科学中相当关键的实体，而数据结构则可以将数据以某种组织形式储存，因此，数据结构的价值不言而喻。
  - 数据需要根据不同的场景，按照特定的格式进行储存。有很多数据结构能够满足以不同格式储存数据的需求。
- **数据结构的分类：**
  1. 线性结构：数组、栈、队列、链表、哈希表
  2. 树结构：二叉树、二叉搜索树、红黑树、堆
  3. 图结构：邻接矩阵、邻接表



# 一. 数组（Array）

## 1. 数组的概念

- 定义：把数据排成一排进行存放。初始化后通过遍历的方式打印。
- 声明：`int[] arr = new int[10]// 声明数组`
- **数组优点：**
  - 随机读取效率很高，因为数组是连续的，知道每一个数据的内存地址，可以直接找到给定地址的数据；
  - 使用数组最好应用于”索引有语义的情况“，换句话说，查学号2的学生成绩；
  - 如果开辟空间过大，即使”索引有语义“，也不适合用数组；
- **数组缺点：**
  - 在无序数组中，搜索性能差（需要遍历数组，时间复杂度O(n)）；
  - 在有序数组中，插入效率低（插入之后的数据需要右移）；
  - 以上两种数组的删除效率都很低；
  - 数组创建后，其大小是固定的；

## 2. 数组的基本操作

- 增 insert(int index, int e)

  1. 将该index位置及其后面的元素全部向后移动

  2. 将该位置设置为e `data[index] = e`

  3. size++

     ```java
     for (int i=size-1; i>=index; i--) {
     		data[i+1] = data[i];
     }
     data[index] = e;
     size++;
     ```

- 删 remove(int index)

  1. 将该元素后面的元素依次向前移动一个位置

  2. size++

     ```java
     for (int i=index+1; i<size; i++) {
     		data[i-1] = data[i];
     }
     size--;
     data[size] = null; //loitering objects != memory leak
     ```

- 改 set(int index, int e)

- 查 find(int e)

  ```java
  for (int i = 0 ;i < size ; i ++){
       if (data[i].equals(e)){
           return i;
        }
  }
  return -1;
  ```

## 3. 二次封装属于自己的数组

- 在”索引没有语义“的情况下，怎么使用数组？怎么表示数组没有元素？怎么添加元素？怎么删除元素？

* Java原本的数组属于静态数组，要解决以上问题，要基于Java数组二次封装属于我们的数组（动态数组）。
* 在自定义数组中添加了：有参无参构造函数，获取数组容量、长度、判断数组是否为空，以及任意位置添加元素（包括添加在最前和最后），删除任意位置元素（包括删除第一和最后一个），修改任意位置元素，查询任意index元素，查询该元素是否存在于数组，存在于哪个位置。

> **注意：**实体类要重写（override）toString()方法，因为object类的toString()方法返回一个”类名+此对象哈希码的无符号十六进制“表示组成：getClass().getName() + '@' + Integer.toHexString(hashCode())。可以理解为重写toString()是对对象打印输出的一种格式化。

## 4. 使用泛型

* 数组类作为存放数据的容器，应该能存放”任意“类型（Java中内置的类型，以及用户自定义的类型）的数据。
* 声明：`E[] data = (E[]) new Object[capacity];`
* 实例化：`ArrayGenericity<Student> arrGen = new ArrayGenericity<>();`
* 示例代码：`datastructure/array/ArrayGenericity.java & Student.java`

## 5. 动态数组

* 数组内部使用Java静态数组，很多时候无法预估到底会往里面放多少元素，在这种情况下，需要数组容量可伸缩：动态数组。
* 解决方法：new一个新的数组，把上面的数组元素依次赋值到newData中，capacity变大，size不变。data引用指向新数组（和newData指向同样的空间）。原来的数组会被回收，newData会失效，只有data指向新数组。
* 添加了一个`resize(int newCapacity)`方法，如果`size==data.length`, 那么将数组扩容至2*data.length; 如果`size==data.lenght/2`,那么将数组缩容至data.length/2.
* 示例代码：`datastructure/array/ArrayDynamic.java @ ArrayDynamicTest.java`

## 6. 面试中相关问题

### 6.1 算法题

1. 寻找数组中第二小的元素

   - 思路：

     1. 初始化两个最小值 firstmin 和 secondmin；
     2. 遍历所有元素，假如当前元素小于firstmin，那么将更新firstmin和secondmin；如果小于secondmin则直接更新secondmin；
     3. 其他情况不做处理，时间复杂度为O(n)。

   - 代码：

     ```java
     public static int findSecondMinimum(int[] arr) {
     		int firstmin = Integer.MAX_VALUE;
     		int secondmin = Integer.MAX_VALUE;
     		for (int i = 0; i < arr.length; i++) {
     			if(arr[i] < firstmin) {
     				secondmin = firstmin;
     				firstmin = arr[i];
     			}else if (arr[i] < secondmin && arr[i] !=firstmin) {
     				secondmin = arr[i];
     			}
     		}
     		return secondmin;
     	}
     ```

2. 寻找数组中第一个不重复出现的整数

3. 合并两个有序数组

4. 重新排列数组中的正值和负值



# 二. 栈（Stack）

# 三. 队列（Queue）

# 四. 链表（Linked List）

# 五. 树（Tree）
